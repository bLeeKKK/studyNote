<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Object</title>
</head>
<body>
    <script>
        // Object上的静态方法

        //  Object.assign(target, origin)  assign/分配
        //  浅拷贝：该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。
        //  方法用于将所有(!!!)可枚举(!!!)属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
        // console.log(Object.assign({c:22},{a:1,b:2}))

        // Object.create(proto,[propertiesObject]) 构造对象 传入的 proto 对象将作为 (!!!)原型(!!!)
        // 第二个参数 propertiesObject 添加属性参数  （产考 Object.defineProperties 的第二个参数）
        // 并且 propertiesObject 的值不是对象或者null时会抛出错误
        // let protoObj = { aa: 999 }
        // console.log(Object.create(protoObj,{
        //     aaaa: {
        //         configurable: true, // configurable/可配置
        //         enumerable: true,   // enumerable/可枚举
        //         value: 11,          // value/值
        //         writable: true,     // writable/可写的
        //     }
        // })

        // // 方法返回一个给定对象自身(!!!)可枚举(!!!)属性的键值对数组
        // // entries/条目
        // console.log(Object.entries({a: '1',b: '2',c: '3'}));
        // // 可用转换为 Map 对象
        // let map = new Map(Object.entries({a: '1',b: '2',c: '3'}));
        // console.log(map)

        // 冻结对象（或数组）不能向这个对象添加新的属性，不能删除已有属性，不能进行修改，冻结同时冻结属性描述和原型，以及不能修改已有属性的值。
        // let obj = {a: '1',b: '2',c: '3'};
        // Object.defineProperty(obj,"d",{
        //     configurable: true,
        //     enumerable: false,
        //     value: 1,
        //     writable: true,
        // }) 
        // // 获取可以枚举和不能枚举的变量名
        // console.log(Object.getOwnPropertyNames(obj))
        // // 获取可以枚举的变量名
        // console.log(Object.keys(obj))
        // Object.freeze(obj);
        // obj.a = 0;
        // console.log(obj)
        // // 判断是否被冻结
        // console.log(Object.isFrozen(obj))

        // seal/封条 封闭属性，不能添加行的属性，同时也不能删除属性，且现有属性标记为不可配置，但是当前属性的值只要可写就可以改变。
        // __proto__ 也会别封闭
        // let obj = {
        //     a:1,
        //     b:2,
        // }
        // Object.seal(obj)

        //  函数传入一个键值对的列表，并返回一个带有这些键值对的新对象 fromEntries/entries/条目
        // let arr = [['a',2],['b',1]] 
        // console.log( Object.fromEntries(arr) )
        // 没这个方法

        // 获取属性描述 
        // console.log( Object.getOwnPropertyDescriptor({a:1},'a') )
        // console.log( Object.getOwnPropertyDescriptors({a:1}) )

        // // 返回一个数组，该数组对元素是 obj自身拥有的(!!!)枚举或不可枚举(!!!)属性名称字符串。
        // console.log( Object.getOwnPropertyNames({a:1,b:9999}) )
        // // 和 getOwnPropertyNames 差不多，您可以将给定对象的所有符号属性作为 Symbol 数组获取
        // console.log( Object.getOwnPropertySymbols({ [Symbol('a')]: 1, b: 9999}) )
        
        // 获取原型
        // console.log( Object.getPrototypeOf({}), Object.getPrototypeOf(Object.getPrototypeOf({})) );

        // 设置原型 这样重新设置有很大性能问题，最好使用 Object.create() 方法创建对象时就设置好原型；
        // Object.setPrototypeOf(obj,prototype)

        // 比较
        // console.log( Object.is(NaN,NaN) , Object.is(0,-0) , Object.is(0,+0))

        // 判断对象是否还可扩展
        // console.log( Object.isExtensible({}) )

        // 返回(!!!)可枚举(!!!)属性的数组
        // console.log( Object.keys( { a:1, b:2 } ) )
        // 返回(!!!)可枚举(!!!)属性的数组
        // console.log( Object.values( { a:1, b:2 } ) )

        // Object实例上的方法
        
        // Object.prototype.propertyIsEnumerable(prop)
        // 判断某个属性是否可以枚举






        //  构造函数的的 prototype 和对象的 __proto__
        //  console.log(function(){}.prototype,{})
        //  function Shape() {
        //     this.x = 0;
        //     this.y = 0;
        //  }
        //  console.log(Shape.prototype === new Shape().__proto__);

        // console.log(Object.getOwnPropertyDescriptor(obj,'a'),Object.getOwnPropertyDescriptors(obj));
        // Object.getOwnPropertyDescriptors(obj);
        // Object.defineProperty();
        // Object.getPrototypeOf();

       

    </script>
</body>
</html>